# Line of best fit {#sec-best-fit-line}

In prior chapters we have looked at the situation when we have a numerical response variable and either no explanatory variable or a single categorical explanatory variable. In this chapter we look at the important case when the response variable and the explanatory variable are numerical.

In this chapter, we continue our model-building journey. A model is simply a rule that takes information we have and produces a predicted value for the response.

-   With no explanatory variable, we learned in @sec-mean-model, that our model is “always predict the mean.”

-   With a single categorical explanatory variable, @sec-category-means showed us that our model should be “predict the mean of the category.”

::: {.callout-note title="Quick Check"}
When we use the sample mean as a model, what value do we predict for every observation?

Why is this considered a model rather than just a summary?
:::

::: {.callout-note collapse="true" title="Answer"}
The model predicts the same value—the sample mean—for every observation.

It is a model because it provides a rule for generating predicted values, not just a numerical description of the data.
:::

::: {.callout-note title="Quick Check"}
How does a category-mean model improve on the overall mean model?

What additional information does it use?
:::

::: {.callout-note collapse="true" title="Answer"}
A category-mean model allows different predictions for different groups.

It improves on the overall mean model by using information about group membership instead of treating all observations as identical.
:::

In this chapter we consider a single numerical explanatory variable. In this case we need something quite different.

## The beach kiosk staffing problem

We again consider a situation where the company gets a hint before making a decision—but now the hint is numerical, not categorical.

The same company operates sales kiosks at the Beach location. Management has noticed that customer traffic at the beach kiosk varies strongly with the day’s high temperature.

Over many past days, the company has recorded:

-   the day’s high temperature (in °F), and

-   the number of customers who visited the beach kiosk that day.

Let us assume that data are available for 25 different days. (As before, for understanding the ideas, the exact number of days is not important.)

@tbl-temp-customers shows the historical data.

| day | temperature | customers |
|:----|------------:|----------:|
| D01 |          58 |        98 |
| D02 |          60 |       104 |
| D03 |          62 |       122 |
| D04 |          64 |       113 |
| D05 |          66 |       117 |
| D06 |          68 |       133 |
| D07 |          70 |       126 |
| D08 |          72 |       115 |
| D09 |          74 |       123 |
| D10 |          76 |       128 |
| D11 |          78 |       145 |
| D12 |          80 |       141 |
| D13 |          58 |       106 |
| D14 |          60 |       107 |
| D15 |          62 |       105 |
| D16 |          64 |       127 |
| D17 |          66 |       120 |
| D18 |          68 |       103 |
| D19 |          70 |       128 |
| D20 |          72 |       121 |
| D21 |          74 |       120 |
| D22 |          76 |       130 |
| D23 |          78 |       127 |
| D24 |          80 |       132 |
| D25 |          58 |        98 |

: Daily temperature and customer counts {#tbl-temp-customers}

Based this, the company must decide how many workers to schedule for tomorrow. It can use an extremely reliable temperature forecast for its city.

The problem now is this:

> Given the high temperature for a day, how many customers should the company plan for?

### How does this differ from earlier examples we have studied?

In @sec-mean-model, we used no hints at all, and the mean turned out to be the best model.

In @sec-category-means, our hint was categorical, and the mean within each category turned out to be the best model.

This time, the situation is fundamentally different. Our hint—temperature—is numerical, and so none of the earlier “mean-based” approaches applies directly.

One possibility would be to convert temperature into categories such as *Cold*, *Warm*, and *Hot*, and then apply the category-means approach. While this would work mechanically, it is somewhat artificial. Two days that differ by only one degree could end up in different categories. For example, calling 50°F Cold and 51°F Warm introduces an arbitrary cutoff that has no real business justification.

Temperature does not naturally fall into clear bins. Can we do better?

### Toward a rule-based model

Rather than assigning a few separate numbers, the company now wants a rule that:

> takes the day’s temperature as input and produces a staffing recommendation as output.

Many such rules are possible. The company wants a simple rule that, takes a temperature as input and produces a predicted number of customers as output. Its output should match the actual number of customers in the data set as well as possible.

@fig-beach-kiosk-model-box-diagram shows what we are looking for at a high level.

![Model that takes a temperature as input and produces a predicted number of customers for the beackh kiosk -- the model should be based on the data in @tbl-temp-customers](../../images/fig-beach-kiosk-model-box-diagram.png){#fig-beach-kiosk-model-box-diagram width="70%" fig-align="center"}

We know that with higher temperatures more people will hit the beach.

This naturally leads us to consider a model which looks something like @fig-specific-beach-kiosk-model-box. We provide the temperature as input and the model uses a *very simple formula* to compute the predicted number of customers for that temperature. Do not take the model in \@@fig-specific-beach-kiosk-model-box too literally -- we just made up the numbers 15 and 2 in the model to illustrate the idea.

![The general shape we want for the beach model -- we have just arbitrarily made up the numbers 15 and 2 in the model to illustrate](../../images/fig-specific-beach-kiosk-model-box.png){#fig-specific-beach-kiosk-model-box width="70%" fig-align="center"}

In reality, we seek a model like @fig-generic-box-model-beach-kiosk. Here the form of the model is fixed. All that remains is to find values for *a* and *b*. The *hat* on top of *cust* in the figure shows that the model computes an *estimated* value. We use the *hat* to distinguish between an actual value in the data set and an *estimated* value.

![Actual form of the model we seek -- in this we need to find good values for b and b](../../images/fig-generic-box-model-beach-kiosk.png){#fig-generic-box-model-beach-kiosk width="70%" fig-align="center"}.

We can express it as a mathematical equation as @eq-kiosk-cust-temp-model shows. We just need to replace *a* and *b* with actual numbers to get a usable model.

$$
\widehat{\text{customers}} = a +  b\,\text{temperature}
$$ {#eq-kiosk-cust-temp-model}

If we fix the values of *a* and *b*, this model produces a predicted number of customers for any temperature. For example, if we fix a value of 15 for *a* and 2 for *b*, then @eq-kiosk-cust-temp-model-specific shows our model to determine the number of customers for any temperature. If we plug in a temperature of 70, the model will give us 155 as the estimated number of customers.

$$
\widehat{\text{customers}} = 15 +  2\,\text{temperature}
$$ {#eq-kiosk-cust-temp-model-specific}

Its prediction changes smoothly as temperature changes, and it avoids arbitrary cutoffs. We just arbitrarily fixed *a* and *b* without any knowledge of how well those choices would perform. What do we mean by *how well those choices would perform?*

If we use the model for many days, then for each day the model gives a prediction and for each day there is an actual number of customers who turn up. The difference between the actual value and the model’s prediction is called a *residual* -- you could call it the error too.

Some residuals are positive and others are negative. If we simply added them up, large positive and negative errors could cancel each other out. Squaring the *residuals* ensures that all errors contribute positively and that larger errors are penalized more heavily. There is also a different reason why we square residuals, but we will not get into that.

If the model's predictions are close to the actual values then the residuals will be low. Therefore, we want the total of all the squared residuals to be as low as we can make it, by choosing good values for *a* and *b*.

We can understand things better through a visualization.

## Visualizing the model

Graphically, @eq-kiosk-cust-temp-model-specific represents a straight line. Let us generate a scatter plot of the data first. @fig-kiosk-temp-cust-scatter shows the plot.

```{r, eval=FALSE}
kiosk |> 
  point_plot(customers ~ temperature)
```

![Scatterplot of *temperature* against number of *customers* from the *kiosk* data frame](../../images/fig-kiosk-temp-cust-scatter.png){#fig-kiosk-temp-cust-scatter width="70%" fig-align="center"}

::: {.callout-note title="Quick Check"}
Looking at the scatterplot of temperature versus customers:

-   Does the relationship appear perfectly linear?
-   Does that prevent us from using a linear model?

Explain briefly.
:::

::: {.callout-note collapse="true" title="Answer"}
The relationship is not perfectly linear; there is noticeable scatter.

This does not prevent us from using a linear model. A linear model is a simplification that captures the overall trend, not a claim that all points lie exactly on a line.
:::

Let us then add the model line from @eq-kiosk-cust-temp-model-specific too on top of it. Right now, we need not concern ourselves with the code. @fig-kiosk-model-initial-attempt shows the scatter plot with the tentative model line.

![Adding a line showing the kiosk model with *a* = 15 and *b* = 1](../../images/fig-kiosk-model-initial-attempt.png){#fig-kiosk-model-initial-attempt width="70%" fig-align="center"}

The model from @eq-kiosk-cust-temp-model-specific when visualized in @fig-kiosk-model-initial-attempt seems way off the mark. Can you see why?

Well, the line represents the model predictions and they are way off from the general region where the points actually lie! For example, we see from @fig-kiosk-model-initial-attempt that two days in our historical data have had a temperature of 64 degrees. The number of customers for those two days have been 113 and 127. But the tentative model from @eq-kiosk-cust-temp-model-specific predicts 143. That does not make sense. So, we clearly did not make great choices for *a* and *b*.

If we want the model predictions to reflect actual data, we would want the line to be within the point cloud. That would make the predictions fall in the general region of the actual values.

Let us try again with different choices for *a* and *b*. How should we change the values? Should we increase or decrease each one?

In @eq-kiosk-cust-temp-model-specific *a* represents where the line intercepts the y-axis at x = 0. You might recall this from your prior mathematics knowledge, but it is fine if you do not. *a* is generally called the *intercept*.

In @fig-kiosk-model-initial-attempt, we cannot see where the line actually intersects the y-axis at x = 0, since the x-axis starts only from around 55. Let us generate a plot that helps us to looks at both the axes starting from 0. @fig-initial-model-with-intercept-visible shows the plot. This is effectively the same plot as @fig-kiosk-model-initial-attempt, only zoomed out so that we can see more.

![Model with *a* = 15 and *b* = 2 plotted to reveal the origin of the plot so as to see the intercept](../../images/fig-initial-model-with-intercept-visible.png){#fig-initial-model-with-intercept-visible width="70%" fig-align="center"}

Even though a temperature of 0°F is well outside our data range, visualizing the intercept helps us understand what changing *a* actually does to the line.

From the plot, we can see that the line correctly intersects the y-axis at 15 since *a = 15*. To make the line go through the point cloud, it looks like we need to make the line less steep. The value for *b* determines the steepness of the line. So, let us decrease it from 2 to 1.5 and see what happens.

![Second attempt: model with *a* = 15 and *b* = 1.5](../../images/fig-kiosk-model-second-guess.png){#fig-kiosk-model-second-guess width="70%" fig-align="center"}

Much better! But can we do even better? We can keep on trying -- we have an infinite number of choices. Can we find the *best* line? What does that even mean?

## What do we mean by the *best* model?

In the previous section, we tried a few values for *a* and *b* and our second attempt proved to be much better than the first. However, we want the *best* line. But what does that even mean?

We are after a model that produces *good* predictions. Therefore the difference between the actual value and the model prediction -- called the *residual* -- matters. The lower that difference is the better. @fig-tentative-model-with-residuals-visualized visualizes our previous model (*a* = 15 and *b* = 1.5) with the error or *residual* explicitly marked for three chosen points.

![Model with *a* = 15 and *b* = 1.5 visualized along with the *residual* or error for three chosen points](../../images/fig-tentative-model-with-residuals-visualized.png){#fig-tentative-model-with-residuals-visualized width="70%" fig-align="center"}

::: {.callout-warning title="Common Misconception"}
The error or *residual* for a prediction is **not** the shortest distance to the line. It is the **vertical difference** between the observed value and the predicted value. This is because our model predicts the response (customers) and we compare that to the actual temperature for any point.
:::

In @fig-tentative-model-with-residuals-visualized, we see that for the point at *temperature* = 62, the actual data had *customers* = 105, whereas our model predicts 108. So the model is off by -3 (if we compute the residual as in @eq-residual-1.

$$
\text{residual} = \text{actual value} - \text{model prediction}
$$ {#eq-residual-1}

For the data point with *temperature* = 68, the model predicts 116, whereas the actual value was 132 for a residual of +16. Finally, for the point where the *temperature* is 76, the model prediction is 129, whereas the actual value was 130. The model did well on this point. In this way, we can compute the *residual* for every point. We are not particularly concerned about the actual sign of the residual. If it is off from the actual, it is off -- does not matter if it is higher or lower. So we remove the sign and talk about the *absolute* residual.

::: {.callout-note title="Quick Check"}
If a model predicts 120 customers for a given temperature, and the actual number is 132:

-   What is the prediction error?
-   Is it positive or negative?
:::

::: {.callout-note collapse="true" title="Answer"}
The prediction error is 132 − 120 = 12.

The error is positive because the actual value is higher than the predicted value.
:::

If we draw any line through these points, each line will have low *absolute residuals* for some points and higher ones for others.

We have many points and so we want an *overall measure of how close the line is to all the points* by considering all the *absolute residuals*. Even if a line is spot on for a few points, it is not very useful if it is wildly off for many others.

As we did before, we will square the residuals from all the points and add them all up. That is how much error the line/model has when we consider all data points. WHat squaring does is to punish bigger residuals much more than smaller ones. This is a standard theme in statistics.

::: {.callout-warning title="What's the deal with squaring?"}
We square errors for the same reason we used squared deviations when defining variance:

-   positive and negative errors should not cancel out
-   larger errors should count more than smaller ones

Least squares regression that we study in this course is built on the same logic as variance. In a later chapter, we will see this idea pop when we look at the explanatory power of a model. Hang tight till then!
:::

::: {.callout-note title="Quick Check"}
Why don’t we choose the line that minimizes the **sum of errors** instead of the **sum of squared errors**?
:::

::: {.callout-note collapse="true" title="Answer"}
Positive and negative errors would cancel out if we summed errors directly.

Squaring errors ensures that all errors contribute positively and that larger errors are penalized more heavily.
:::

Clearly, we want a line that is as close as possible to all the points overall. Honestly, the line in @fig-tentative-model-with-residuals-visualized seems to be pretty good, at least visually.

For this model (a = 15, b = 1.5), the total of all the squared residuals is: 1,469.

Is there a line that can give an even lower value? What are the values for *a* and *b* for which we get the *lowest* possible total of all the squared residuals?

::: {.callout-note title="Key Idea"}
Since there is an infinite number of possible choices for *a* and *b*, we need a systematic way to find the values that minimize the total of the squared residuals. Mathematically, this problem can be solved using calculus. Practically, we sit back and let software do this for us.
:::

::: {.callout-note title="Pause & Think"}
Complete the sentence:

“A least squares regression line is the line that \_\_\_\_\_.”
:::

::: {.callout-note collapse="true" title="Answer"}
A least squares regression line is the line that minimizes the sum of squared vertical prediction errors.
:::

The code below generates the *best* values for *a* and *b* that guarantee that the *sum of squared residuals* is the smallest possible.

```{r}
kiosk |> 
  model_train(customers ~ temperature) |> 
  coef()
```

We see two values in the output: *intercept* and *temperature*. The first is *a* and the second is *b*! These are exactly the values of *a* and *b* that minimize the sum of squared residuals.

@eq-kiosk-cust-temp-model-best shows the *best model* for our problem, given that we want a straight line and want to minimize the sum of squared residuals is:

$$
\widehat{\text{customers}} = 22.06 +  1.42\,\text{temperature}
$$ {#eq-kiosk-cust-temp-model-best}

The optional enrichment topic at the end of the chapter talks about possibilities other than straight lines.

Let us now see if the sum of squared residuals is smaller than what we obtained for our previous choices for *a* and *b*: 1,469.

The value is: 1,387. Lower, as we expected. But not by much. We had eyeballed very good values for *a* and *b*!

We found a line that *minimizes the sum of squared residuals*. Technically this is called the *least-squares criterion* and plays a very important role in statistics and data analysis.

::: {.callout-note title="Pause & Think"}
Suppose tomorrow’s high temperature is 73°F. Your model predicts 124 customers.

-   Does this mean exactly 124 customers will arrive?
-   What other factors (besides temperature) might cause the actual number to be higher or lower?

What does this tell you about what a regression model can—and cannot—do?
:::

::: {.callout-note icon="false" collapse="true"}
## Suggested answer

-   No. 124 is only a model prediction. In reality the number of customers may be 124 or higher or lower.

-   The model acts as if only the temperature determines the number of customers. In reality, many other factors play a role too. Perhaps there is a football game in town and that draws people away. Perhaps the humidity is unusually high and people stay away. Many factors play a role in this outcode. Our model uses a simple rule that can potentially perform decently without being accurate.

In later chapters we will see that we can include more variables in a model and improve its performance.
:::

## Optional enrichment topic: Beyond straight lines

In this chapter, we have assumed that a straight line is a reasonable model for the relationship between temperature and customer traffic. In many business settings, this assumption works well: simple models are easy to interpret, easy to communicate, and often good enough for decision-making.

However, not all relationships are well captured by a straight line.

### When a straight line may not be appropriate

In some situations, a scatter plot may reveal patterns such as:

-   curvature (the relationship bends),

-   diminishing returns (the effect of increases slows down), or

-   threshold effects (behavior changes after a certain point).

For example, at very high temperatures, customer traffic at a beach kiosk might level off or even decline as conditions become uncomfortable. A straight line cannot capture this kind of behavior well, no matter how its slope and intercept are chosen.

In such cases, forcing a linear model may lead to systematic residual patterns, indicating that the model is missing something important.

### A flexible alternative: LOWESS smoothing

One way to explore nonlinear relationships is through a technique called LOWESS (short for locally weighted scatter plot smoothing).

@fig-lowess-example shows an example of a LOWESS model using the *mpg* data frame. In this data frame the *displacement* of an engine is related to the highway mileage *hwy*, but not in a linear way. The LOWESS model better describes it than a straight line would. Like the earlier line model, this too can take in a value for *displ* and provide an estimated value for *hwy*.

![LOWESS model for *displacement* vs *cty* in the *mpg* data frame showing how it captures the curvature in the relationship better than a lien can](../../images/fig-lowess-example.png){#fig-lowess-example width="70%" fig-align="center"}

Rather than fitting a single global rule like a straight line, LOWESS works by:

-   focusing on a small neighborhood of points around each value of the explanatory variable, and

-   fitting simple local models that adapt to the data in that neighborhood.

The result is a smooth curve that follows the overall pattern of the data without requiring us to specify a particular functional form in advance.

LOWESS is especially useful for:

-   exploratory analysis,

-   visualizing trends, and

-   diagnosing whether a straight-line model is reasonable.

It is not intended to replace regression models in all cases, but rather to help us understand the structure of the data.

### Models as choices, not defaults

The key takeaway is not that linear models are “wrong,” but that models are choices.

-   A straight line is a good choice when the relationship is approximately linear and interpretability matters.

-   A nonlinear model may be a better choice when the data clearly suggest curvature or changing behavior.

-   Flexible tools like LOWESS help us see what the data are trying to tell us before we commit to a specific model.

In all cases, the central modeling question remains the same:

> Does this model capture the important structure in the data well enough to support the decisions we want to make?

This mindset—treating models as purposeful approximations rather than automatic formulas—will guide us throughout the rest of this book.
