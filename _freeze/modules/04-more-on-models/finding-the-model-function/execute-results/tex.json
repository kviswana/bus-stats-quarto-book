{
  "hash": "7b5afccf6be9d698cab248c3914b3e1a",
  "result": {
    "engine": "knitr",
    "markdown": "# Finding the Model Function {#sec-model-functions}\n\nOur journey so far has introduced the idea of models and shown us the intuition, and rationale behind models. We have also seen how to visualize the models. However, we have not lingered too much on systematically building models and reconstructing the model function from what R shows us about the models.\n\nThis chapter closes the loop.\n\n## Finding the model function for models with no explanatory variables\n\nWhen we have a numerical outcome variable and no explanatory variable, @sec-mean-model showed us that the *best* model would be to predict the mean or average. We look at two ways of building such models:\n\n- building the model by explicitly computing the mean\n- using the model_train function (our go to method from now on)\n\n### Building mean models by explicitly computing the mean\n\nDo you remember how to compute the mean oif a variable?\n\n::: {.callout-note icon=false}\n## Quick Check {.unnumbered}\n\nGiven a hypothetical data frame named *dat* do you recall how to compute the mean of one of its variables named *col* using R?\n:::\n\n::: {.callout-note icon=false collapse=true}\n## Suggested answer {.unnumbered}\n\ndat |> \n    summarize(avg_col = mean(col))\n:::\n\nUsing the *txhousing* data frame, we can build a model for the number of listings as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntxhousing |>\n    summarize(avg_listings = mean(listings))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 1\n  avg_listings\n         <dbl>\n1           NA\n```\n\n\n:::\n:::\n\n\nWhy is the result not a number? Why did we get *NA*?\n\nYou might recall from @sec-missing-values that *NA* means missing value. Why is the mean of *listings* a missing value? The *txhousing* data frame has some missing values in the column *listings*. As a result, our code is unable to compute the average. Suppose I asked you what is 2 + 3, you can say \"5.\" since you have both the numbers that you want to add up. \n\nHowever, if I asked you what is *NA* + 5? You cannot say what it is because you do not know the values of the two numbers you are trying to sum. In general, whenever *NA* is involved in an operation, the result is always *NA*.\n\nThis is very inconvenient. Wht does the system simply not ignore the *NA*s and compute the average of the remaining numbers? By default it does not do that, but we can make the system do that in the following way.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntxhousing |>\n    summarize(avg_listings = mean(listings, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 1\n  avg_listings\n         <dbl>\n1        3217.\n```\n\n\n:::\n:::\n\n\nWhen you add \"na.rm = TRUE\", R leaves out the missing values and computes the average of the rest. Remember, R is case sensitive and so you have to type \"na.rm\" in lowercase and \"TRUE\" in uppercase. Otherwise you will get an error.\n\nSo we saw that the mean of *listings* is 3217 and that is our model value.\n\nWe can write the model function as @eq-txhousing-listings-mean-model\n\n$$\n\\widehat{\\text{listings}} = 3217\n$$ {#eq-txhousing-listings-mean-model}\n\nWe have built the mean model by explicitly writing code to compute the average. \n\n::: {.callout-note icon=false}\n## Quick Check {.unnumbered}\n\nIn @sec-mean-model, we saw a situation where the interns had to find a single fixed number to represent the number of customers who will show up at a kiosk on any day. What could be a business analogue of that in the *listings* example from the *txhousing* data frame?\n:::\n\n::: {.callout-note icon=false collapse=true}\n## Suggested answer {.unnumbered}\n\nThe analogue would be: We need to build a model for the number of listings in a typical month, and we were allowed to give just a single fixed number for it. Also, like before, bigger errors are penalized more strongly through squaring prediction errors.\n:::\n\n### Building the mean model using *model_train*\n\nThe *model_train* function greatly simplifies the process of building models irrespective of the form of the model. We do not need to worry about what types of explanatory variables and how many of them are involved.\n\nLet us see how to use it to build the model for *listings* with no explanatory variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntxhousing |>\n    model_train(listings ~ 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nA trained model relating the response variable \"listings\"\nto explanatory variable \"\".\n\nTo see relevant details, use model_eval(), conf_interval(),\nR2(), regression_summary(), anova_summary(), or model_plot(),\nor the native R model-reporting functions.\n```\n\n\n:::\n:::\n\n\nWe have built the model, but the output does not give us any details about the model to enable us to reconstruct the model function.\n\nWe can fix that easily by calling another function -- *coef* -- to get the model *coefficients*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntxhousing |>\n    model_train(listings ~ 1) |>\n    coef()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(Intercept) \n       3217 \n```\n\n\n:::\n:::\n\n\nThe output says that the *intercept* is 3217 (rounded). The model output does not show any other coefficients because we do not have any explanatory variables. From this, we can reconstruct the model function as @eq-txhousing-listings-mean-model-copy (same as @fig-txhousing-listings-mean-model). We explain below exactly how we went from the coefficients in the output to @eq-txhousing-listings-mean-model-copy.\n\n$$\n\\widehat{\\text{listings}} = 3217\n$$ {#eq-txhousing-listings-mean-model-copy}\n\nYou night recall from @sec-best-fit-line that in general when we have a single explanatory variable, we are trying to find the best values for *a* and *b* in an equation of the from that @eq-generic provides to compute an estimated value for the outcome variable (hence the *hat*)\n\n$$\n\\widehat{\\text{outcome}} = a + b\\,\\,\\text{explanatory\\_var}\n$$ {#eq-generic}\n\nThe *intercept* in the model coefficients output by the *coef* function corresponds to *a*. If there is another coefficient in the output that corresponds to *b*. In the current example we have only the *intercept* and no other coefficient and so we use only *a* in reconstructing the model function as @eq-txhousing-listings-mean-model-copy.\n\nLet us consider another example using the *mpg* data frame. We will now build a model for *cty* with no explanatory variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpg |> \n  model_train(cty ~ 1) |> \n  coef()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(Intercept) \n       16.9 \n```\n\n\n:::\n:::\n\nWe see that the *intercept* is 16.86 (rounded). This is, of course, the mean of *cty*. @eq-mpg-cty-mean-model shows the model function.\n\n$$\n\\widehat{\\text{cty}} = 16.9\n$$ {#eq-mpg-cty-mean-model}\n\n::: {.callout-note icon=false}\n## Quick Check {.unnumbered}\n\nCan you think of a business scenario where this sort of model might be used?\n:::\n\n::: {.callout-note icon=false collapse=true}\n## Suggested answer {.unnumbered}\n\nIf a company had a fleet of cars and needed to estimate something based on the city mileage of the fleet as a whole and we had to settle on juse a single representative number for the whole fleet, then the average would be the best -- assuming again that bigger errors are more heavily penalized.\n:::\n\n\nLet us close out with another example from the *Anthro_F* data frame to predict body fat (variable *BFat) with no explanatory variables. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nAnthro_F |> \n  model_train(BFat ~ 1) |> \n  coef()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(Intercept) \n       21.8 \n```\n\n\n:::\n:::\n\n\nThis shows an *intercept* of 21.8 (rounded). @eq-anthro-f-bfat-model shows the model function.\n\n$$\n\\widehat{\\text{BFat}} = 21.8\n$$ {#eq-anthro-f-bfat-model}\n\n::: {.callout-note icon=false}\n## Quick Check {.unnumbered}\n\nAs before, what might be a usage scenario for this model?\n:::\n\n::: {.callout-note icon=false collapse=true}\n## Suggested answer {.unnumbered}\n\nIf, for some reason we needed a representative number -- a single number -- for the body fat of a group of college age females in the age range 18-25 (as the data set on which we based the model), then this model would work.\n:::\n\n::: callout-tip\n## Steps to build the model function for models with no explanatory variable\n\n1. Determine the tilde expression for your model (like listings ~ 1, or some such)\n1. Pipe the data frame to the *model_train* function and pass the tilde expression as well\n1. Pipe the output of the *model_train* function to the *coef()* function\n1. Look at the results and map the *intercept* to *a* \n1. Construct the model function by substituting the name of the outcome variable and the value of *a* in the equation with the intercept: \n$$\n\\widehat{\\text{outcome\\_var}} = \\text{a}\n$$ \n:::\n\n## Finding the model function for models with one explanatory variable alone\n\nMirroring the process from the previous section, we have two ways of building these models:\n\n- building the model by explicitly computing the category means\n- using the model_train function (our go to method from now on)\n\n### Building category mean models by explicitly computing category means\n\nLet us use the *Boston_marathon* data frame to build a model for *minutes* with *sex* as the explanatory variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nBoston_marathon |> \n  summarize(avg_minutes = mean(minutes), .by = sex)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 x 2\n  sex    avg_minutes\n  <chr>        <dbl>\n1 male          142.\n2 female        150.\n```\n\n\n:::\n:::\n\n\nIn the above code, if we had not used \".by = sex\", we would have got the overall mean. But using \".by = sex\" computes a separate mean for each value of *sex*.\n\nWe now have the mean of *minutes* for each sex and can build the model function as:\n\n$$\n\\widehat{\\text{minutes}} =\n\\begin{cases}\n142 & \\text{if } \\text{sex} = \\text{\"male\"} \\\\\n150 & \\text{if } \\text{sex} = \\text{\"female\"}\n\\end{cases}\n$$ {#eq-boston-marathon-minutes-sex-model}\n\nAs before, this is needlessly cumbersome. We can do this using the *model_train* function like before.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nBoston_marathon |> \n  model_train(minutes ~ sex) |> \n  coef()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(Intercept)     sexmale \n     149.87       -8.33 \n```\n\n\n:::\n:::\n\n\nThe output looks a bit different now. We have the *intercept* as before. But we have a single coefficient named *sexmale*.\n\nWhen we have categorical explanatory variables, the *model_train* function reports coefficients a bit differently than what we did earlier.\n\nOur explanatory variable has two possible values, *female* and *male*. The intercept represents the model value for one of these -- typically, the alphabetically lowest one -- in this case *female* as *f* comes alphabetically before *m*.\n\nSo the coefficient 149.86, which we wil round to 10 is the model value for *female* as our earlier computations also showed. This is the base value. The coefficient for *sexmale* shows the coefficient value for *male* relative to that for the base. This means that the coefficient for *male* is *less* (because it is negative) than that for female by 8.33. The coefficient for *male* is approximately 142.\n\nSo we can construct the model function as:\n\n$$\n\\widehat{\\text{minutes}} =\n\\begin{cases}\n142 & \\text{if } \\text{sex} = \\text{\"female\"} \\\\\n142 & - 8\\,\\, \\text{if } \\text{sex} = \\text{\"male\"}\n\\end{cases}\n$$ {#eq-boston-marathon-minutes-sex-model-1}\n\n\n@eq-boston-marathon-minutes-sex-model-1 is effectively the same as @eq-boston-marathon-minutes-sex-model, but written slightly differently.\n\nYou should read it as, if *sex* is \"female\" then the model value is 150. If *sex* is \"male\" then the model value is 8 minutes lower (negative sign). \n\nDoes this make sense? It does, because we know that males run slightly faster than females and so their finishing time will be lower.\n\n::: {.callout-note icon=false}\n## Quick Check {.unnumbered}\n\nWhat would be the use case scenario for this model?\n:::\n\n::: {.callout-note icon=false collapse=true}\n## Suggested answer {.unnumbered}\n\nIf the race organizers are planning to do something based on the typical race completion time and can do something different for male and female participants, then the average finishing times for each gender would be a good model.\n:::\n\nLet us consider one more example using the *acct_type_balance* data frame with *balance* as the outcome variable and *bank_account_type* as the explanatory variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nacct_type_balance |> \n  model_train(balance ~ bank_account_type) |> \n  coef()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n             (Intercept) bank_account_typeSavings \n                    4901                     1016 \n```\n\n\n:::\n:::\n\n\nThe output shows the intercept as 4901. Our explanatory variable *bank_account_type* has two possible values *Savings* and *Checking*. From the previous example, we know that the *coef()* function will treat one of these as the base.\n\n::: {.callout-note icon=false}\n## Quick Check {.unnumbered}\n\nWHich account tyoe will it treat as the base? *Checking* or *Savings*?\n:::\n\n::: {.callout-note icon=false collapse=true}\n## Suggested answer {.unnumbered}\n\n*Checking** because \"C\" is alphabetically before \"S\".\n:::\n\n*Checking* is the base and its average is reported as the *intercept* and the model value for *Savings* is reported relative to the model value for *Checking*.\n\nThe model function therefore becomes:\n\n$$\n\\widehat{\\text{balance}} =\n\\begin{cases}\n4901 & \\text{if } \\text{bank\\_account\\_type} = \\text{\"Checking\"} \\\\\n4901 & + 1016\\,\\, \\text{if } \\text{bank\\_account\\_type} = \\text{\"Savings\"}\n\\end{cases}\n$$ {#eq-bank-acct-type-bal-model}\n\nThe model says that \nsavings accounts generally have a higher account balance than checking accounts. Makes sense.\n\n::: callout-tip\n## Steps to build the model function for models with one categorical explanatory variable\n\n1. Determine the tilde expression for your model (like balance ~ bank_account_type, or some such)\n1. Pipe the data frame to the *model_train* function and pass the tilde expression as well\n1. Pipe the output of the *model_train* function to the *coef()* function\n1. Find which category has been used as the base and note the intercept\n1. Note the coefficients for each of the other categories\n1. Construct the model function by substituting the name of the outcome variable, and the value of the intercept in the following equation.\n1. Then add conditions for each additional category suitably substituting the appropriate category names.\n$$\n\\widehat{\\text{outcome}} =\n\\begin{cases}\nintercept & \\text{if } \\text{explanatory variable} = \\text{base category} \\\\\nintercept & + \\,\\text{coef1} \\, \\text{if } \\text{explanatory variable} = \\text{\"category 1\"} \\\\\nintercept & +\\, \\text{coef2} \\, \\text{if } \\text{explanatory variable} = \\text{\"category 2\"} \\\\\nintercept & +\\, \\text{coef3} \\, \\text{if } \\text{explanatory variable} = \\text{\"category 3\"}\n\\end{cases}\n$$ \n\n:::\n\n## Finding the model function for models with a single numerical explanatory variable\n\nUnlike the two mean models, we have no direct computation approach. We will just use the *model_train* function.\n\nWe will build a model using the *mpg* data frame with the highway mileage (variable *hwy*) as the outcome variable and the engine displacement (*displ*) as the explanatory variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpg |> \n  model_train(hwy ~ displ) |> \n  coef()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(Intercept)       displ \n      35.70       -3.53 \n```\n\n\n:::\n:::\n\n\nAs before, we substitute the \"intercept* for *a* and in the case of a numerical explanatory variable, we substitute the other coefficient for *b*.\n\n@eq-mpg-hwy-displ-model shows the model function.\n\n$$\n\\widehat{\\text{hwy}} = 36 - 3.5\\, \\text{displ}\n$$ {#eq-mpg-hwy-displ-model}\n\nLet us see another example. We use the *Hill_racing* data frame to build a model with *time* (finishing time measured in seconds) as the outcome variable, and)*distance* (measured in km) as the explanatory variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nHill_racing |> \n  model_train(time ~ distance) |> \n  coef()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(Intercept)    distance \n       -211         381 \n```\n\n\n:::\n:::\n\n\nWe see that the *intercept* is -211. The coefficient for *distance* is 381.\n\nLet us build the model function before talking about the crazy-seeming negative *intercept*.\n\n$$\n\\widehat{\\text{time}} = -211 + 381\\, \\text{distance}\n$$ {#eq-hill-racing-time-distance-model}\n\nDoes it make sense that the coefficient for *distance* is positive? Per @eq-hill-racing-time-distance-model, as *distance* increases, the estimated *time* will increase. This makes sense.\n\nWhat about the *intercept* of -211? \n\nFrom @eq-hill-racing-time-distance-model, we see that if there is a hypothetical race with distance of 0 km, then the model says that people will finish the race 211 seconds before the race starts!  \n\nObviously that makes no sense as time works in the normal world. SO what is going on?\n\nModels are approximate and we can only expect reasonable results within the range of data on which they were built. We need to be wary of interpreting models very outside of their scope. In our dataset, the shortest race is 1.1 km and the average is 10.7 km.\n\nFor the 1.,1 km race, the model predicts a time of 208 seconds or around 3.5 minutes, which seems reasonable -- given that these are \"hill\" races.\n\n::: {.callout-note icon=false}\n## Quick Check {.unnumbered}\n\nWhat would be a scenario where this model can help?\n:::\n\n::: {.callout-note icon=false collapse=true}\n## Suggested answer {.unnumbered}\n\nThe organizers are getting ready to conduct the races again. Now, they want to give an estimated completion time (one single number) for each race. They can use this model to find this time based on the distance of each race.\n:::\n\n::: callout-tip\n## Steps to build the model function for models with one numerical explanatory variable\n\n1. Determine the tilde expression for your model (like hwy ~ displ, or some such)\n1. Pipe the data frame to the *model_train* function and pass the tilde expression as well\n1. Pipe the output of the *model_train* function to the *coef()* function\n1. Note the *intercept* and the *coefficient* for the explanatory variable (expl_coeff)\n1. Construct the model function by substituting the name of the outcome variable, and the value of the intercept in the following equation.\n1. Then add conditions for each additional category suitably substituting the appropriate category names.\n$$\n\\widehat{\\text{outcome}} = \\text{intercept} + \\text{expl\\_var\\_coeff}\\,\\,\\text{explanatory variable}\n$$ \n:::\n\n",
    "supporting": [
      "finding-the-model-function_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}